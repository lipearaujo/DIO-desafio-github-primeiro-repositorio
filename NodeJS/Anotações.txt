Node.js
- O NodeJs √© um ambiente de execu√ß√£o do JavaScript em server-side. Ele nos d√° a possibilidade de rodar localmente o JavaScript fora do navegador por exemplo.

- Temos a possibilidade de rodar o JavaScript sem precisar de um navegador, diminuindo o processamento e trabalhando com interpreta√ß√£o just-in-time

- O nodejs, diferente de outros interpretadores, trabalha com single-thread, ou seja, imagina que cada requisi√ß√£o √© um pedido de delivery... vai chegar uma hora que o quadro de pedidos vai estar cheio e se tiver um pedido que ainda n√£o foi produzido e entregue, ele vai bloquear a passagem dos outros pedidos, gerando insatisfa√ß√£o dos clientes. Coitado do entregador.
O nodejs trabalha com requisi√ß√µes ass√≠ncronas, ou seja, n√£o precisa esperar todos os pedidos, vai entregando o que for ficando pronto. Assim todo mundo sai feliz.üòä Assim, o processamento √© n√£o-bloqueante(non-blocking), pois funciona mesmo sem uma requisi√ß√£o estar pronta, do contr√°rio seria bloqueante(blocking) e tudo ficaria parado.
Consequentemente, o entregador n√£o precisa mais ficar preocupado e entrega o pedido assim que o mesmo for finalizado, depois volta no quadro de pedidos, pega os que faltaram e entrega logo ap√≥s. Chamamos isso de Event-Loop.

- O Node trabalha com single-thred
	single-thred: cria uma pilha com as fun√ß√µes chamadas e executa uma por vez, mesmo que elas sejam concorrentes
	multi-thred: executa as fun√ß√µes paralelamente, independentes se estas s√£o concorrentes

- As requisi√ß√µes no Node s√£o ass√≠ncronas

- Blocking: s√≠ncrono, pois a entrega depende que todas as requisi√ß√µes estejam prontas 
- Non-blocking: ass√≠ncrono, pois a entrega √© feita mesmo sem todas as requisi√ß√µes estarem prontas (trabalha com o Event-loop)
- Event-loop: execu√ß√£o das requisi√ß√µes de forma ass√≠ncrona

NPM
- Ferramenta de gerenciamento de pacotes do Node

Criando packaje.json
- npm init

Dependencias:
	- Instalando nodemon: 
	yarn add nodemon
	editar "scripts" em packaje.json e adicionar "start": "nodemon index.js" (caso o index n√£o esteja na pasta raiz, passar o caminho do diret√≥rio)

	- Instalando express:
	yarn add express
	editar em packaje.json e adicionar "type": "module"

Configurando typescript:
	- Instalando typescript como dependecia de desenvolvimento
	yarn add -D typescript

	Compilar o arquivo ts: yarn tsc nomeDoArquivo.ts
	ap√≥s compilar o arquivo ts, gerar√° um arquivo com o mesmo nome porem com a extensao js. Esse arquivo que rodaremos com: node nomeDoArquivo.js
	
	Ferramenta para facilitar a compila√ß√£o: yarn add -D ts-node-dev
	editar "scripts" em packaje.json e adicionar "dev": "ts-node-dev src/index.ts"

	Instalar as tipagens do express para usar com typescript
	yarn add -D @types/express 

Instalando e configurando jest:
	yarn add -D jest
	yarn add -D @types/jest
	yarn add -D ts-jest

	inicializando o jest na aplica√ß√£o: npx jest --init

	ir ate o arquivo jest.config.ts e descomentar as linhas de testMatch
	ir ate o arquivo jest.config.ts, descomentar as linhas de preset e modificar: preset: 'ts-jest'

Extens√µes vsCode:
	Thunder client
	Jest runner


Para a build do nosso projeto:
	editar "scripts" em packaje.json e adicionar "build": "rm -rf ./build && tsc"
	editar "scripts" em packaje.json e modificar "start": "node build/index.js"
	editar "type" em packaje.json e modificar "type": "commonjs"
	editar e descomentar em tsconfig.json "outdir": "./build"
	adicionar em tsconfig.json as pastas que queremos ou n√£o enviar para o projeto final
		"include":[] - pastas dentro das chaves ser√£o enviadas
		"exclude":[] - pastas dentro das chaves n√£o ser√£o enviadas

	Ao final executar yarn build e yarn start


API REST
- API REST, tamb√©m chamada de API RESTful, √© uma interface de programa√ß√£o de aplica√ß√µes (API ou API web) que est√° em conformidade com as restri√ß√µes do estilo de arquitetura REST, 
permitindo a intera√ß√£o com servi√ßos web RESTful. REST √© a sigla em ingl√™s para "Representational State Transfer", que em portugu√™s significa tansfer√™ncia de estado representacional.

API
- Uma API √© um conjunto de defini√ß√µes e protocolos usado no desenvolvimento e na integra√ß√£o de aplica√ß√µes. 
√Äs vezes, as APIs s√£o descritas como um contrato entre um provedor e um usu√°rio de informa√ß√µes, estabelecendo o conte√∫do exigido pelo consumidor (a chamada) e o conte√∫do exigido pelo produtor (a resposta). 
Por exemplo, o design da API de um servi√ßo meteorol√≥gico pode especificar que o usu√°rio forne√ßa um CEP e o produtor responda em duas partes, 
a primeira contendo a temperatura mais elevada e a segunda com a temperatura mais baixa.  

Em outras palavras, ao interagir com um computador ou sistema para recuperar informa√ß√µes ou executar uma fun√ß√£o, 
a API ajudar√° a comunicar o que voc√™ quer ao sistema para que ele entenda e realize o que foi solicitado. 

Pense nas APIs como um mediador entre os usu√°rios ou clientes e os recursos ou servi√ßos web que eles querem obter. 
As APIs tamb√©m servem para que organiza√ß√µes compartilhem recursos e informa√ß√µes e, ao mesmo tempo, mantenham a seguran√ßa, o controle e a obrigatoriedade de autentica√ß√£o, pois permitem determinar quem tem acesso e o que pode ser acessado.


REST
- REST n√£o √© um protocolo ou padr√£o, mas sim um conjunto de restri√ß√µes de arquitetura. Os desenvolvedores de API podem implementar a arquitetura REST de maneiras variadas.

Quando um cliente faz uma solicita√ß√£o usando uma API RESTful, essa API transfere uma representa√ß√£o do estado do recurso ao solicitante ou endpoint. 
Essa informa√ß√£o (ou representa√ß√£o) √© entregue via HTTP utilizando um dos v√°rios formatos poss√≠veis: Javascript Object Notation (JSON), HTML, XLT, Python, PHP ou texto sem formata√ß√£o. 
O formato JSON √© a linguagem de programa√ß√£o mais usada porque, apesar de seu nome, √© independente de qualquer outra linguagem e pode ser lido por m√°quinas e humanos. 

Lembre-se tamb√©m de que cabe√ßalhos e par√¢metros s√£o importantes nos m√©todos HTTP de uma solicita√ß√£o HTTP de API RESTful porque cont√™m informa√ß√µes relevantes sobre o identificador, 
bem como metadados, autoriza√ß√£o, Uniform Resource Identifier (URI), cache, cookies e outras informa√ß√µes da solicita√ß√£o. 
H√° os cabe√ßalhos da solicita√ß√£o e os cabe√ßalhos da resposta, cada um contendo as informa√ß√µes de suas respectivas conex√µes HTTP e c√≥digos de status.

Para que uma API seja considerada do tipo RESTful, ela precisa est√° em conformidade com os seguintes crit√©rios:
 1 - Ter uma arquitetura cliente/servidor formada por clientes, servidores e recursos, com solicita√ß√µes gerenciadas por HTTP.
 2 - Estabelecer uma comunica√ß√£o stateless entre cliente e servidor. Isso significa que nenhuma informa√ß√£o do cliente √© armazenada entre solicita√ß√µes GET e toda as solicita√ß√µes s√£o separadas e desconectadas.
 3 - Armazenar dados em cache para otimizar as intera√ß√µes entre cliente e servidor.
 4 - Ter uma interface uniforme entre os componentes para que as informa√ß√µes sejam transferidas em um formato padronizado. Para tanto, √© necess√°rio que:
	4.1 - os recursos solicitados sejam identific√°veis e estejam separados das representa√ß√µes enviadas ao cliente;
	4.2 - os recursos possam ser manipulados pelo cliente por meio da representa√ß√£o recebida com informa√ß√µes suficientes para tais a√ß√µes;
	4.3 - as mensagens autodescritivas retornadas ao cliente contenham informa√ß√µes suficientes para descrever como process√°-las;
	4.4 - hipertexto e hiperm√≠dia est√£o dispon√≠veis. Isso significa que ap√≥s acessar um recurso, o cliente pode usar hiperlinks para encontrar as demais a√ß√µes dispon√≠veis para ele no momento.
 5 - Ter um sistema em camadas que organiza os tipos de servidores (respons√°veis pela seguran√ßa, pelo carregamento de carga e assim por diante) envolvidos na recupera√ß√£o das informa√ß√µes solicitadas em hierarquias que o cliente n√£o pode ver.
 6 - Possibilitar c√≥digo sob demanda (opcional): a capacidade de enviar um c√≥digo execut√°vel do servidor para o cliente quando solicitado para ampliar a funcionalidade dispon√≠vel ao cliente. 

Embora uma API REST precise estar em conformidade com os crit√©rios acima, ela √© considerada mais f√°cil de usar do que um protocolo prescrito, como o Protocolo Simples de Acesso a Objetos (SOAP). 
Esse tipo de protocolo tem requisitos espec√≠ficos, como o sistema de mensageria XML, al√©m de precisar cumprir com exig√™ncias de seguran√ßa incorporada e transa√ß√µes, o que o torna mais lento e pesado. 

Em compara√ß√£o, a arquitetura REST √© composta de um conjunto de diretrizes que podem ser implementadas conforme necess√°rio. Isso faz com que as APIs REST sejam mais r√°pidas, leves e escal√°veis, o que √© ideal para a Internet das Coisas (IoT) e o desenvolvimento de aplicativos mobile.


/* O aplicativo inicia um servidor e escuta a porta 5000 por conex√µes. 
O aplicativo responde com ‚ÄúHello World!‚Äù √† solicita√ß√µes para a URL raiz (/) ou rota. 
Para todos os outros caminhos, ele ir√° responder com um 404 N√£o Encontrado. */

const express = require("express");
const app = express();
const port = 5000;

app.use(express.json());

app.get("/", (req, res) => {
  res.send("Hello World");
});

app.listen(port, () => {
  console.log(`Connected on port ${port}`);
});

/* O req (solicita√ß√£o) e res (resposta) s√£o os mesmos objetos que o Node fornece, para que seja poss√≠vel chamar o req.pipe(), req.on('data', callback), e 
qualquer outra coisa que desejaria fazer sem o envolvimento do Express. */

/* O Roteamento refere-se √† determina√ß√£o de como um aplicativo responde a uma solicita√ß√£o do cliente por um endpoint espec√≠fico, 
que √© uma URI (ou caminho) e um m√©todo de solicita√ß√£o HTTP espec√≠fico (GET, POST, e assim por diante).
Cada rota pode ter uma ou mais fun√ß√µes de manipula√ß√£o, que s√£o executadas quando a rota √© correspondida.
A defini√ß√£o de rotas aceita a seguinte estrutura: 
app.METHOD(PATH, HANDLER) Onde:
    app √© uma inst√¢ncia do express.
    METHOD √© um m√©todo de solicita√ß√£o HTTP.
    PATH √© um caminho no servidor.
    HANDLER √© a fun√ß√£o executada quando a rota √© correspondida.

Os seguintes exemplos ilustram a defini√ß√£o de rotas simples.
Responder com Hello World! na p√°gina inicial:
app.get('/', function (req, res) {
  res.send('Hello World!');
});

Responder a uma solicita√ß√£o POST na rota raiz (/) com a p√°gina inicial do aplicativo:
app.post('/', function (req, res) {
  res.send('Got a POST request');
});

Responder a uma solicita√ß√£o PUT para a rota /user:
app.put('/user', function (req, res) {
  res.send('Got a PUT request at /user');
});

Responder a uma solicita√ß√£o DELETE para a rota /user:
app.delete('/user', function (req, res) {
  res.send('Got a DELETE request at /user');
});

*/



















